package ro.scoalaPeterThal;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

import repository.BookRepository;
import repository.BookSpecification;
import repository.GenreRepository;
import basics.*;
import jakarta.servlet.http.HttpSession;
import jakarta.validation.Valid;

import java.time.LocalDate;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Controller
public class BookContrl {
	@Autowired
	BookRepository bookRepository;

	@Autowired
	GenreRepository genreRepository;
	@Autowired
	private HttpSession session;

	@GetMapping("/books")
	public String BooksList() {
		return "bookslist";
	}

	public List<Genre> getAllGenres() {
		return genreRepository.findAll();
	}

	@GetMapping("/addBook")
	public String showAddBookForm(Model model) {
		if (!CheckIfUserIsLoggedIn())
			return "redirect:/login";
		model.addAttribute("book", new Book());
		model.addAttribute("genres", genreRepository.findAll());
		return "addBook";
	}

	@PostMapping("/addBook")
	public String addBook(@Valid @ModelAttribute Book book, BindingResult result, Model model) {

		if (result.hasErrors()) {

			model.addAttribute("genres", genreRepository.findAll());
			return "addBook";
		}
		bookRepository.save(book);
		return "addBook";
	}

	public Boolean CheckIfUserIsLoggedIn() {
		AppUser sessionUser = (AppUser) session.getAttribute("sessionUser");

		return sessionUser != null;
	}

	@GetMapping("/booksAjax")
	@ResponseBody
	public Map<String, Object> getBooks(@RequestParam(value = "title", required = false) String title,
			@RequestParam("draw") int draw, @RequestParam(value = "author", required = false) String author,
			@RequestParam(value = "publicationYear", required = false) Integer publicationYear,
			@RequestParam(value = "genre", required = false) String genreId,
			@RequestParam(value = "search[value]", required = false) String searchValue,
			@RequestParam(value = "start", defaultValue = "0") int start,
			@RequestParam(value = "length", defaultValue = "10") int length,
			@RequestParam(value = "order[0][column]", defaultValue = "0") int orderColumn,
			@RequestParam(value = "order[0][dir]", defaultValue = "asc") String orderDir) {

		// Paginare
		Pageable pageable = PageRequest.of(start / length, length, "asc".equals(orderDir)
				? Sort.by(orderColumn == 0 ? "title" : orderColumn == 1 ? "author" : "publicationYear")
				: Sort.by(orderColumn == 0 ? "title" : orderColumn == 1 ? "author" : "publicationYear").descending());
		Long genId = null;
		if (genreId != "") {
			List<Genre> genres = genreRepository.findFirstByNameContaining(genreId);

			System.out.println(genreId + " " + genres);
			genId = (genres != null && !genres.isEmpty()) ? genres.get(0).getId() : null;
		}
		List<Book> books = searchBooksByFilter(title, author, genId, publicationYear, searchValue, pageable);

		Map<String, Object> response = new HashMap<>();
		response.put("draw", draw);
		response.put("recordsTotal", bookRepository.count());
		response.put("recordsFiltered", books.size());
		response.put("data", books);

		return response;
	}

	@GetMapping("/booksAjaxWithAvailability")
	@ResponseBody
	public Map<String, Object> getBooksWithAvailability(@RequestParam(value = "title", required = false) String title,
			@RequestParam("draw") int draw, @RequestParam(value = "author", required = false) String author,
			@RequestParam(value = "publicationYear", required = false) Integer publicationYear,
			@RequestParam(value = "genre", required = false) String genreId,
			@RequestParam(value = "search[value]", required = false) String searchValue,
			@RequestParam(value = "start", defaultValue = "0") int start,
			@RequestParam(value = "length", defaultValue = "10") int length,
			@RequestParam(value = "order[0][column]", defaultValue = "0") int orderColumn,
			@RequestParam(value = "order[0][dir]", defaultValue = "asc") String orderDir) {

		// Paginare
		Pageable pageable = PageRequest.of(start / length, length, "asc".equals(orderDir)
				? Sort.by(orderColumn == 0 ? "title" : orderColumn == 1 ? "author" : "publicationYear")
				: Sort.by(orderColumn == 0 ? "title" : orderColumn == 1 ? "author" : "publicationYear").descending());
		Long genId = null;
		if (genreId != "") {
			List<Genre> genres = genreRepository.findFirstByNameContaining(genreId);

			genId = (genres != null && !genres.isEmpty()) ? genres.get(0).getId() : null;
		}

		List<Book> books = searchBooksByFilter(title, author, genId, publicationYear, searchValue, pageable);
		List<BookDTO> bookDTOs = new ArrayList<>();
		for (Book book : books) {
			BookDTO bookDTO = new BookDTO();
			bookDTO.setTitle(book.getTitle());
			bookDTO.setAuthor(book.getAuthor());
			bookDTO.setGenre(book.getGenre());
			bookDTO.setPublicationYear(book.getPublicationYear());
			bookDTO.setAvailability(getAvailabilityStatus(book));
			bookDTOs.add(bookDTO);
		}
		long totalRecords = bookDTOs.size();
		System.out.println(start);
		var startPage=start==0?length:start+1;
		int toIndex = (int) Math.min(start+length, (int) totalRecords);
		if (start >= totalRecords) {
	        toIndex = (int) totalRecords;
	    }
		System.out.println(toIndex);
		List<BookDTO> paginatedBooks = bookDTOs.subList(start, toIndex);
		Map<String, Object> response = new HashMap<>();
		response.put("draw", draw);
		response.put("recordsTotal", bookRepository.count());
		response.put("recordsFiltered", bookRepository.count());
		response.put("data", paginatedBooks);

		return response;
	}

	public List<Book> searchBooksByFilter(String title, String author, Long genreId, Integer publicationYear,
			String searchValue, Pageable pageable) {

		return bookRepository.findBooksByCriteria(title, author, genreId, publicationYear, searchValue, pageable);
	}

	public String getAvailabilityStatus(Book book) {
		// Verifică dacă există împrumuturi care nu au fost returnate
		for (Loan loan : book.getLoans()) {
			if (loan.getReturnDate().isAfter(LocalDate.now())) {
				return "Împrumutat până la " + loan.getReturnDate();
			}
		}
		return "Disponibil";
	}
}
